import { v4 } from 'uuid';
import { merge, fling } from './util';
import { type, force, call, kind, or, bool, nothing } from './be';
import { Type, copy } from './Type';
import { Free } from './monad';
import { Spawn, Send, Receive, Fork, Fault } from './System';

/**
 * ActorT is a template for creating actors that run in
 * the same event loop as the system.
 * @property {string} id - must be unique
 * @property {function} start - Actor →  Actor
 */
export class ActorT extends Type {}

/**
 * LocalT is a template for creating a local actor
 * @property {string} id
 * @property {function} start
 */
export class LocalT extends ActorT {

    constructor(props) {

        super(props, {

            id: type(String),
            start: type(Function)

        });

    }

}

/**
 * FutureT is the template for spawning future actors.
 * @property {string} id
 * @property {string} to
 * @property {Future} future
 */
export class FutureT extends ActorT {

    constructor(props) {

        super(props, {
            id: call(v4),
            to: type(String),
            future: kind(Future)
        });

    }

}

/**
 * Actor
 */
export class Actor extends Type {}

/**
 * ActorL
 */
export class ActorL extends Actor {

    constructor(props) {

        super(props, {

            parent: type(String),
            path: type(String),
            mailbox: or(type(Array), force([])),
            ops: or(type(Free), force(null)),
            template: type(ActorT)

        });

    }

    drain(sys) {

        return sys.copy({
            ops: this.ops ? sys.ops.concat(this.ops) : sys.ops,
            actors: merge(sys.actors, {
                [this.path]: this.copy({ ops: null })
            })
        });

    }

    accept(message) {

        return copy(this, { mailbox: this.mailbox.concat(message.message) });

    }

}

/**
 * ActorFT contains a Future, a computation that we expect to be complete sometime
 * later.
 * @property {string} to - The actor to send the result to.
 * @property {string} parent
 * @property {Future} future
 * @property {Join} result
 * @property {Fault} rejection
 */
export class ActorFT extends Actor {

    constructor(props) {

        super(props, {

            to: type(String),
            from: or(type(String), nothing),
            parent: type(String),
            path: type(String),
            future: kind(Future),
            ops: or(type(Free), nothing),
            iOps: or(type(Array), force([])),
            forked: or(type(Boolean), force(false))

        });

    }

    drain(sys) {

        if (this.forked === true) {

            if (this.ops == null)
                returnsys

            else return sys.copy({
                ops: sys.ops.concat(this.ops),
                actors: fling(this.path, sys.actors)
            })

        } else {

            sys.copy({
                ops: sys.ops.concat(
                    Free.liftF(new Fork({
                        fork: () =>
                            this
                            .future
                            .fork(
                                error => this.iOps.push(new Fault({
                                    parent: this.parent,
                                    error
                                })),
                                message => this.iOps.push(new Send({
                                    to: this.to,
                                    from: this.from || this.path,
                                    message
                                })))
                    }))),
                actors: merge(sys.actors, {
                    [this.path]: new ActorFT(merge(this, { ops: null, forked: true }))
                })
            });

        }

        }

    }

    /**
     * Future represents some computation we are interested in getting the result of
     * that may not complete now or run asynchronously. This class serves
     * as an interface for type checking.
     * @interface
     */
    export class Future {

        /**
         * fork the Future
         * @param {function} onReject
         * @param {function} onResolve
         */
        fork() {}

    }

    /**
     * ActorContext
     */
    export class ActorContext extends Type {

        constructor(props) {

            super(props, {

                parent: type(String),
                self: type(String)

            });

        }

        /**
         * spawn a new child actor
         * @param {ActorT} template
         * @return {Free}
         */
        spawn(template) {

            return Free.liftF(new Spawn({ template, parent: this.self }));

        }

        /**
         * tell another actor something
         * @param {string} to
         * @param {*} message
         * @summary { (string, *) →  Free}
         */
        tell(to, message) {

            return Free.liftF(new Send({ from: this.self, to, message }));

        }

        /**
         * receive the next message, optionally filtering unwanted
         * messages.
         * @summary { (* →  Free | null ) →  Free }
         */
        receive(behaviour) {

            if (typeof behaviour !== 'function')
                throw new TypeError(`receive(): behaviour must be a function got '${typeof f}'!`);

            return Free.liftF(new Receive({ path: this.self, behaviour }));

        }

        /**
         * future
         */
        future(f) {

            if (!bool(kind(Future)(f)))
                throw new TypeError(`future(): f must implement Future!`);

            return Free.liftF(new Spawn({
                template: new FutureT({
                    to: this.path,
                    parent: this.self,
                    future: f
                }),
                parent: this.self
            }));

        }

    }
