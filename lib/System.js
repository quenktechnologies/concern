"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Promise = require("bluebird");
var PendingContext_1 = require("./PendingContext");
var DuplicateActorPathError_1 = require("./DuplicateActorPathError");
var Message_1 = require("./Message");
exports.INFO = 6;
exports.WARN = 5;
exports.ERROR = 1;
/**
 * makeChildPath creates a child path given an actor and a child id
 */
exports.makeChildPath = function (id, parent) {
    return ((parent === '/') || (parent === '')) ? "" + parent + id : parent + "/" + id;
};
/**
 * ASEvent is the superclass of all events generated by
 * the system.
 */
var ASEvent = (function () {
    function ASEvent() {
    }
    return ASEvent;
}());
exports.ASEvent = ASEvent;
/**
 * ChildSpawnedEvent
 */
var ChildSpawnedEvent = (function (_super) {
    __extends(ChildSpawnedEvent, _super);
    function ChildSpawnedEvent(address) {
        var _this = _super.call(this) || this;
        _this.address = address;
        return _this;
    }
    return ChildSpawnedEvent;
}(ASEvent));
exports.ChildSpawnedEvent = ChildSpawnedEvent;
/**
 * MessageSentEvent
 */
var MessageSentEvent = (function (_super) {
    __extends(MessageSentEvent, _super);
    function MessageSentEvent(to, from, message) {
        var _this = _super.call(this) || this;
        _this.to = to;
        _this.from = from;
        _this.message = message;
        return _this;
    }
    return MessageSentEvent;
}(ASEvent));
exports.MessageSentEvent = MessageSentEvent;
/**
 * MessageDroppedEvent
 */
var MessageDroppedEvent = (function (_super) {
    __extends(MessageDroppedEvent, _super);
    function MessageDroppedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MessageDroppedEvent;
}(MessageSentEvent));
exports.MessageDroppedEvent = MessageDroppedEvent;
/**
 * MessageReceivedEvent
 */
var MessageReceivedEvent = (function (_super) {
    __extends(MessageReceivedEvent, _super);
    function MessageReceivedEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MessageReceivedEvent;
}(MessageSentEvent));
exports.MessageReceivedEvent = MessageReceivedEvent;
/**
 * ReceiveStartedEvent
 */
var ReceiveStartedEvent = (function (_super) {
    __extends(ReceiveStartedEvent, _super);
    function ReceiveStartedEvent(path) {
        var _this = _super.call(this) || this;
        _this.path = path;
        return _this;
    }
    return ReceiveStartedEvent;
}(ASEvent));
exports.ReceiveStartedEvent = ReceiveStartedEvent;
/**
 * LoggingLogic contains the logic for system logging.
 */
var LoggingLogic = (function () {
    function LoggingLogic(policy) {
        this.policy = policy;
    }
    LoggingLogic.createFrom = function (p) {
        return new LoggingLogic(p);
    };
    /**
     * childSpawned
     */
    LoggingLogic.prototype.childSpawned = function (ref) {
        if (this.policy.level >= exports.INFO)
            this.policy.logger.info(new ChildSpawnedEvent(ref));
    };
    /**
     * messageDropped
     */
    LoggingLogic.prototype.messageDropped = function (m) {
        if (this.policy.level >= exports.WARN)
            this.policy.logger.warn(new MessageDroppedEvent(m.to, m.from, m.message));
    };
    /**
     * messageSent
     */
    LoggingLogic.prototype.messageSent = function (m) {
        if (this.policy.level >= exports.INFO)
            this.policy.logger.info(new MessageSentEvent(m.to, m.from, m.message));
    };
    /**
     * messageReceived
     */
    LoggingLogic.prototype.messageReceived = function (m) {
        if (this.policy.level >= exports.INFO)
            this.policy.logger.info(new MessageReceivedEvent(m.to, m.from, m.message));
    };
    /**
     * receiveStarted
     */
    LoggingLogic.prototype.receiveStarted = function (path) {
        if (this.policy.level >= exports.INFO)
            this.policy.logger.info(new ReceiveStartedEvent(path));
    };
    return LoggingLogic;
}());
exports.LoggingLogic = LoggingLogic;
var defaults = {
    log: { level: exports.WARN, logger: console }
};
/**
 * System is a system of actors.
 */
var System = (function () {
    function System(config, actors, logging, path) {
        if (config === void 0) { config = defaults; }
        if (actors === void 0) { actors = {}; }
        if (logging === void 0) { logging = LoggingLogic.createFrom(config.log); }
        if (path === void 0) { path = ''; }
        this.config = config;
        this.actors = actors;
        this.logging = logging;
        this.path = path;
    }
    /**
     * create a new system
     */
    System.create = function (c) {
        return new System(c);
    };
    /**
     * spawn a new top level actor within the system.
     */
    System.prototype.spawn = function (t) {
        this.putChild(t, this.path);
        return this;
    };
    /**
     * putChild creates a new child actor for a parent within the system.
     */
    System.prototype.putChild = function (t, parent) {
        var path = exports.makeChildPath(t.id, parent); //@todo validate actor ids
        var child = t.create(path, this);
        if (this.actors.hasOwnProperty(path))
            throw new DuplicateActorPathError_1.DuplicateActorPathError(path); //@todo use supervision instead
        this.actors[path] = child;
        this.logging.childSpawned(path);
        child.start();
        return path;
    };
    /**
     * dropMessage drops a message.
     */
    System.prototype.dropMessage = function (m) {
        this.logging.messageDropped(m);
    };
    /**
     * putContext replaces an actor's context within the system.
     */
    System.prototype.putContext = function (path, context) {
        this.actors[path] = context;
    };
    /**
     * putMessage places a message into an actor's context.
     *
     * Messages are enveloped to help the system keep track of
     * communication. The message may be processed or stored
     * depending on the target actor's state at the time.
     * If the target actor does not exist, the message is dropped.
     */
    System.prototype.putMessage = function (to, from, message) {
        var actor = this.actors[to];
        var m = new Message_1.Message(to, from, message);
        if (!actor) {
            this.dropMessage(m);
        }
        else {
            this.logging.messageSent(m);
            actor.feed(m);
        }
    };
    /**
     * askMessage allows an actor to ignore incomming messages unless
     * they have been sent by a specific actor.
     */
    System.prototype.askMessage = function (to, from, m) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.actors[from] = new PendingContext_1.PendingContext(to, _this.actors[from], resolve, _this);
            _this.putMessage(to, from, m);
        });
    };
    return System;
}());
exports.System = System;
//# sourceMappingURL=System.js.map