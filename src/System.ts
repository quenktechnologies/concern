import * as Promise from 'bluebird';
import { Context } from './Context';
import { PendingContext } from './PendingContext';
import { Template } from './Template';
import { DuplicateActorPathError } from './DuplicateActorPathError';
import { Message } from './Message';

export const INFO = 6;
export const WARN = 5;
export const ERROR = 1;

/**
 * makeChildPath creates a child path given an actor and a child id
 */
export const makeChildPath = (id: string, parent: string): string =>
    ((parent === '/') || (parent === '')) ? `${parent}${id}` : `${parent}/${id}`;

/**
 * ASEvent is the superclass of all events generated by
 * the system.
 */
export class ASEvent { }

/**
 * Logger is an interface for intercepting events generated
 * by the actor system.
 */
export interface Logger {

    info(e: ASEvent);
    warn(e: ASEvent);
    error(e: ASEvent);

}

/**
 * ChildSpawnedEvent 
 */
export class ChildSpawnedEvent extends ASEvent {

    constructor(public address: string) { super(); }

}

/**
 * MessageSentEvent 
 */
export class MessageSentEvent<M> extends ASEvent {

    constructor(public to: string, public from: string, public message: M) { super(); }

}

/**
 * MessageDroppedEvent 
 */
export class MessageDroppedEvent<M> extends MessageSentEvent<M>{ }

/**
 * MessageReceivedEvent 
 */
export class MessageReceivedEvent<M> extends MessageSentEvent<M>{ }

/**
 * ReceiveStartedEvent 
 */
export class ReceiveStartedEvent extends ASEvent {

    constructor(public path: string) { super(); }

}

export interface Configuration { log: LoggingPolicy }

export interface LoggingPolicy {

    level: number;
    logger: Logger;

}

/**
 * LoggingLogic contains the logic for system logging.
 */
export class LoggingLogic {

    constructor(public policy: LoggingPolicy) { }

    static createFrom(p: LoggingPolicy) {

        return new LoggingLogic(p);

    }

    /**
     * childSpawned 
     */
    childSpawned(ref: string) {

        if (this.policy.level >= INFO)
            this.policy.logger.info(new ChildSpawnedEvent(ref));

    }

    /**
     * messageDropped 
     */
    messageDropped<M>(m: Message<M>) {

        if (this.policy.level >= WARN)
            this.policy.logger.warn(new MessageDroppedEvent(m.to, m.from, m.message));

    }

    /**
     * messageSent 
     */
    messageSent<M>(m: Message<M>) {

        if (this.policy.level >= INFO)
            this.policy.logger.info(new MessageSentEvent(m.to, m.from, m.message));

    }

    /**
     * messageReceived 
     */
    messageReceived<M>(m: Message<M>) {

        if (this.policy.level >= INFO)
            this.policy.logger.info(new MessageReceivedEvent(m.to, m.from, m.message));

    }

    /**
     * receiveStarted 
     */
    receiveStarted(path: string) {

        if (this.policy.level >= INFO)
            this.policy.logger.info(new ReceiveStartedEvent(path));

    }

}

const defaults = {
    log: { level: WARN, logger: console }
};

/**
 * System is a system of actors.
 */
export class System {

    constructor(
        public config: Configuration = defaults,
        public actors: object = {},
        public logging: LoggingLogic = LoggingLogic.createFrom(config.log),
        public path = '') { }

    /**
     * create a new system
     */
    static create(c?: Configuration) {

        return new System(c);

    }

    /**
     * spawn a new top level actor within the system.
     */
    spawn(t: Template): System {

        this.putChild(t, this.path);
        return this;

    }

    /**
     * putChild creates a new child actor for a parent within the system.
     */
    putChild(t: Template, parent: string): string {

        var path = makeChildPath(t.id, parent); //@todo validate actor ids
        var child = t.create(path, this);

        if (this.actors.hasOwnProperty(path))
            throw new DuplicateActorPathError(path); //@todo use supervision instead

        this.actors[path] = child;
        this.logging.childSpawned(path);

        child.start();

        return path;

    }

    /**
     * dropMessage drops a message.
     */
    dropMessage<M>(m: Message<M>) {

        this.logging.messageDropped(m);

    }

    /**
     * putContext replaces an actor's context within the system.
     */
    putContext(path: string, context: Context) {

        this.actors[path] = context;

    }

    /**
     * putMessage places a message into an actor's context.
     *
     * Messages are enveloped to help the system keep track of 
     * communication. The message may be processed or stored 
     * depending on the target actor's state at the time. 
     * If the target actor does not exist, the message is dropped.
     */
    putMessage<M>(to: string, from: string, message: M) {

        let actor = this.actors[to];
        let m = new Message(to, from, message);

        if (!actor) {
            this.dropMessage(m);
        } else {
            this.logging.messageSent(m);
            actor.feed(m);
        }

    }

    /**
     * askMessage allows an actor to ignore incomming messages unless
     * they have been sent by a specific actor.
     */
    askMessage<M>(to: string, from: string, m: M) {

        return new Promise(resolve => {

            this.actors[from] = new PendingContext(to, this.actors[from], resolve, this);
            this.putMessage(to, from, m);

        });

    }

}
